"""
Sistema de Seguridad Antimalware para Anclora RAG
Escaneo de archivos antes de la conversi√≥n documental
"""

import os
import hashlib
import logging
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
from datetime import datetime
import tempfile
import subprocess
import json

# Try to import magic for MIME type detection, fallback if not available
try:
    import magic
    MAGIC_AVAILABLE = True
except ImportError:
    MAGIC_AVAILABLE = False

# Configuraci√≥n de logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class ScanResult:
    """Resultado del escaneo de seguridad."""
    file_path: str
    is_safe: bool
    threat_level: str  # 'safe', 'suspicious', 'malicious', 'corrupted'
    threats_detected: List[str]
    file_type: str
    file_size: int
    scan_time: datetime
    quarantine_path: Optional[str] = None
    additional_info: Optional[Dict[str, Any]] = None

class MalwareScanner:
    """
    Sistema de escaneo antimalware para archivos de conversi√≥n.
    
    Implementa m√∫ltiples capas de seguridad:
    1. Validaci√≥n de tipo de archivo
    2. An√°lisis de firmas conocidas
    3. Detecci√≥n de patrones sospechosos
    4. Verificaci√≥n de integridad
    5. Cuarentena de archivos peligrosos
    """
    
    def __init__(self, quarantine_dir: str = "/tmp/quarantine"):
        self.quarantine_dir = Path(quarantine_dir)
        self.quarantine_dir.mkdir(exist_ok=True, parents=True)
        
        # Extensiones permitidas para conversi√≥n
        self.allowed_extensions = {
            '.pdf', '.docx', '.doc', '.txt', '.md', '.html', '.htm',
            '.rtf', '.odt', '.epub', '.mobi', '.csv', '.json', '.xml',
            '.pptx', '.ppt', '.xlsx', '.xls', '.zip', '.rar', '.7z',
            '.mp3', '.mp4', '.avi', '.ogg', '.oga', '.srt', '.vtt',
            '.py', '.js', '.sql', '.r', '.scala', '.kotlin', '.swift'
        }
        
        # Firmas de malware conocidas (hashes MD5 de archivos maliciosos)
        self.malware_signatures = {
            # Ejemplos de hashes maliciosos conocidos
            "d41d8cd98f00b204e9800998ecf8427e",  # Archivo vac√≠o sospechoso
            "5d41402abc4b2a76b9719d911017c592",  # "hello" - ejemplo
        }
        
        # Patrones sospechosos en contenido
        self.suspicious_patterns = [
            b'<script',
            b'javascript:',
            b'vbscript:',
            b'eval(',
            b'exec(',
            b'system(',
            b'shell_exec',
            b'passthru',
            b'base64_decode',
            b'<?php',
            b'<%',
            b'powershell',
            b'cmd.exe',
            b'rundll32',
        ]
        
        # Tama√±os m√°ximos por tipo de archivo (en bytes)
        self.max_file_sizes = {
            '.pdf': 100 * 1024 * 1024,    # 100MB
            '.docx': 50 * 1024 * 1024,    # 50MB
            '.doc': 50 * 1024 * 1024,     # 50MB
            '.zip': 200 * 1024 * 1024,    # 200MB
            '.mp4': 500 * 1024 * 1024,    # 500MB
            '.mp3': 50 * 1024 * 1024,     # 50MB
            'default': 25 * 1024 * 1024   # 25MB por defecto
        }
    
    def scan_file(self, file_path: str) -> ScanResult:
        """
        Escanea un archivo completo para detectar amenazas.

        Args:
            file_path: Ruta al archivo a escanear

        Returns:
            ScanResult: Resultado completo del escaneo
        """
        start_time = datetime.now()
        file_path_obj = Path(file_path)
        
        logger.info(f"üîç Iniciando escaneo de seguridad: {file_path_obj.name}")

        try:
            # Verificaciones b√°sicas
            if not file_path_obj.exists():
                return ScanResult(
                    file_path=file_path,
                    is_safe=False,
                    threat_level='corrupted',
                    threats_detected=['Archivo no encontrado'],
                    file_type='unknown',
                    file_size=0,
                    scan_time=start_time
                )

            file_size = file_path_obj.stat().st_size
            file_extension = file_path_obj.suffix.lower()
            
            # 1. Validaci√≥n de extensi√≥n
            extension_check = self._check_extension(file_extension)
            if not extension_check['is_valid']:
                return self._create_threat_result(
                    file_path_obj, 'malicious', extension_check['threats'],
                    file_size, start_time
                )

            # 2. Validaci√≥n de tama√±o
            size_check = self._check_file_size(file_size, file_extension)
            if not size_check['is_valid']:
                return self._create_threat_result(
                    file_path_obj, 'suspicious', size_check['threats'],
                    file_size, start_time
                )

            # 3. Detecci√≥n de tipo MIME
            mime_check = self._check_mime_type(file_path_obj)
            if not mime_check['is_valid']:
                return self._create_threat_result(
                    file_path_obj, 'suspicious', mime_check['threats'],
                    file_size, start_time
                )

            # 4. Verificaci√≥n de firmas de malware
            signature_check = self._check_malware_signatures(file_path_obj)
            if not signature_check['is_valid']:
                return self._create_threat_result(
                    file_path_obj, 'malicious', signature_check['threats'],
                    file_size, start_time, quarantine=True
                )

            # 5. An√°lisis de contenido sospechoso
            content_check = self._check_suspicious_content(file_path_obj)
            if not content_check['is_valid']:
                threat_level = 'malicious' if content_check['severity'] == 'high' else 'suspicious'
                return self._create_threat_result(
                    file_path_obj, threat_level, content_check['threats'],
                    file_size, start_time, quarantine=(threat_level == 'malicious')
                )

            # 6. Verificaci√≥n de integridad
            integrity_check = self._check_file_integrity(file_path_obj)
            if not integrity_check['is_valid']:
                return self._create_threat_result(
                    file_path_obj, 'corrupted', integrity_check['threats'],
                    file_size, start_time
                )

            # Archivo seguro
            logger.info(f"‚úÖ Archivo seguro: {file_path_obj.name}")
            return ScanResult(
                file_path=file_path,
                is_safe=True,
                threat_level='safe',
                threats_detected=[],
                file_type=mime_check['mime_type'],
                file_size=file_size,
                scan_time=start_time,
                additional_info={
                    'scan_duration': (datetime.now() - start_time).total_seconds(),
                    'checks_passed': ['extension', 'size', 'mime', 'signature', 'content', 'integrity']
                }
            )
            
        except Exception as e:
            logger.error(f"‚ùå Error durante el escaneo de {file_path}: {e}")
            return ScanResult(
                file_path=str(file_path),
                is_safe=False,
                threat_level='corrupted',
                threats_detected=[f'Error de escaneo: {str(e)}'],
                file_type='unknown',
                file_size=file_size if 'file_size' in locals() else 0,
                scan_time=start_time
            )
    
    def _check_extension(self, extension: str) -> Dict[str, Any]:
        """Verifica si la extensi√≥n del archivo est√° permitida."""
        if extension not in self.allowed_extensions:
            return {
                'is_valid': False,
                'threats': [f'Extensi√≥n no permitida: {extension}'],
                'severity': 'high'
            }
        return {'is_valid': True}
    
    def _check_file_size(self, file_size: int, extension: str) -> Dict[str, Any]:
        """Verifica si el tama√±o del archivo est√° dentro de los l√≠mites."""
        max_size = self.max_file_sizes.get(extension, self.max_file_sizes['default'])
        
        if file_size > max_size:
            return {
                'is_valid': False,
                'threats': [f'Archivo demasiado grande: {file_size / 1024 / 1024:.1f}MB > {max_size / 1024 / 1024:.1f}MB'],
                'severity': 'medium'
            }
        
        if file_size == 0:
            return {
                'is_valid': False,
                'threats': ['Archivo vac√≠o'],
                'severity': 'medium'
            }
        
        return {'is_valid': True}
    
    def _check_mime_type(self, file_path: Path) -> Dict[str, Any]:
        """Verifica el tipo MIME del archivo."""
        try:
            if MAGIC_AVAILABLE:
                mime_type = magic.from_file(str(file_path), mime=True)
            else:
                # Fallback: detectar por extensi√≥n
                ext = file_path.suffix.lower()
                mime_map = {
                    '.pdf': 'application/pdf',
                    '.doc': 'application/msword',
                    '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                    '.txt': 'text/plain',
                    '.html': 'text/html',
                    '.htm': 'text/html',
                    '.md': 'text/markdown',
                    '.csv': 'text/csv',
                    '.json': 'application/json',
                    '.xml': 'application/xml',
                    '.zip': 'application/zip',
                    '.rar': 'application/x-rar-compressed',
                    '.mp3': 'audio/mpeg',
                    '.mp4': 'video/mp4',
                    '.avi': 'video/x-msvideo',
                    '.ogg': 'audio/ogg',
                    '.oga': 'audio/ogg',
                    '.py': 'text/x-python',
                    '.js': 'application/javascript'
                }
                mime_type = mime_map.get(ext, 'application/octet-stream')

            # Tipos MIME permitidos
            allowed_mimes = {
                'application/pdf', 'application/msword',
                'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                'text/plain', 'text/html', 'text/markdown', 'text/csv',
                'application/json', 'application/xml', 'text/xml',
                'application/zip', 'application/x-rar-compressed',
                'audio/mpeg', 'video/mp4', 'video/x-msvideo',
                'audio/ogg', 'text/x-python', 'application/javascript',
                'application/octet-stream'  # Para archivos sin extensi√≥n espec√≠fica
            }

            if mime_type not in allowed_mimes:
                return {
                    'is_valid': False,
                    'threats': [f'Tipo MIME no permitido: {mime_type}'],
                    'severity': 'medium',
                    'mime_type': mime_type
                }

            return {'is_valid': True, 'mime_type': mime_type}

        except Exception as e:
            return {
                'is_valid': False,
                'threats': [f'Error detectando tipo MIME: {str(e)}'],
                'severity': 'medium',
                'mime_type': 'unknown'
            }
    
    def _check_malware_signatures(self, file_path: Path) -> Dict[str, Any]:
        """Verifica firmas de malware conocidas."""
        try:
            # Calcular hash MD5 del archivo
            md5_hash = hashlib.md5()
            with open(file_path, 'rb') as f:
                for chunk in iter(lambda: f.read(4096), b""):
                    md5_hash.update(chunk)
            
            file_hash = md5_hash.hexdigest()
            
            if file_hash in self.malware_signatures:
                return {
                    'is_valid': False,
                    'threats': [f'Firma de malware detectada: {file_hash}'],
                    'severity': 'critical'
                }
            
            return {'is_valid': True, 'hash': file_hash}
            
        except Exception as e:
            return {
                'is_valid': False,
                'threats': [f'Error calculando hash: {str(e)}'],
                'severity': 'medium'
            }
    
    def _check_suspicious_content(self, file_path: Path) -> Dict[str, Any]:
        """Busca patrones sospechosos en el contenido del archivo."""
        try:
            threats = []
            severity = 'low'
            
            with open(file_path, 'rb') as f:
                # Leer primeros 64KB para an√°lisis
                content = f.read(65536)
                
                for pattern in self.suspicious_patterns:
                    if pattern in content:
                        threats.append(f'Patr√≥n sospechoso detectado: {pattern.decode("utf-8", errors="ignore")}')
                        severity = 'high'
            
            if threats:
                return {
                    'is_valid': False,
                    'threats': threats,
                    'severity': severity
                }
            
            return {'is_valid': True}
            
        except Exception as e:
            return {
                'is_valid': False,
                'threats': [f'Error analizando contenido: {str(e)}'],
                'severity': 'medium'
            }
    
    def _check_file_integrity(self, file_path: Path) -> Dict[str, Any]:
        """Verifica la integridad b√°sica del archivo."""
        try:
            # Intentar abrir y leer el archivo
            with open(file_path, 'rb') as f:
                f.read(1024)  # Leer primeros 1KB
            
            return {'is_valid': True}
            
        except (IOError, OSError, PermissionError) as e:
            return {
                'is_valid': False,
                'threats': [f'Archivo corrupto o inaccesible: {str(e)}'],
                'severity': 'high'
            }
    
    def _create_threat_result(self, file_path: Path, threat_level: str, 
                            threats: List[str], file_size: int, 
                            scan_time: datetime, quarantine: bool = False) -> ScanResult:
        """Crea un resultado de amenaza y opcionalmente pone en cuarentena."""
        
        quarantine_path = None
        if quarantine:
            quarantine_path = self._quarantine_file(file_path)
        
        logger.warning(f"‚ö†Ô∏è Amenaza detectada en {file_path.name}: {threat_level}")
        for threat in threats:
            logger.warning(f"   - {threat}")
        
        return ScanResult(
            file_path=str(file_path),
            is_safe=False,
            threat_level=threat_level,
            threats_detected=threats,
            file_type='unknown',
            file_size=file_size,
            scan_time=scan_time,
            quarantine_path=quarantine_path,
            additional_info={
                'scan_duration': (datetime.now() - scan_time).total_seconds(),
                'quarantined': quarantine
            }
        )
    
    def _quarantine_file(self, file_path: Path) -> Optional[str]:
        """Mueve un archivo peligroso a cuarentena."""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            quarantine_name = f"{timestamp}_{file_path.name}"
            quarantine_path = self.quarantine_dir / quarantine_name

            # Mover archivo a cuarentena
            file_path.rename(quarantine_path)

            # Crear archivo de metadatos
            metadata = {
                'original_path': str(file_path),
                'quarantine_time': timestamp,
                'file_size': quarantine_path.stat().st_size,
                'reason': 'Malware detected'
            }

            metadata_path = quarantine_path.with_suffix('.metadata.json')
            with open(metadata_path, 'w') as f:
                json.dump(metadata, f, indent=2)

            logger.info(f"üîí Archivo puesto en cuarentena: {quarantine_path}")
            return str(quarantine_path)

        except Exception as e:
            logger.error(f"‚ùå Error poniendo archivo en cuarentena: {e}")
            return None

    def get_quarantine_stats(self) -> Dict[str, Any]:
        """Obtiene estad√≠sticas de archivos en cuarentena."""
        try:
            quarantine_files = list(self.quarantine_dir.glob("*"))
            metadata_files = [f for f in quarantine_files if f.suffix == '.json']
            actual_files = [f for f in quarantine_files if f.suffix != '.json']
            
            total_size = sum(f.stat().st_size for f in actual_files)
            
            return {
                'total_files': len(actual_files),
                'total_size_mb': total_size / 1024 / 1024,
                'quarantine_dir': str(self.quarantine_dir),
                'oldest_file': min((f.stat().st_mtime for f in actual_files), default=0),
                'newest_file': max((f.stat().st_mtime for f in actual_files), default=0)
            }
            
        except Exception as e:
            logger.error(f"Error obteniendo estad√≠sticas de cuarentena: {e}")
            return {'error': str(e)}

# Instancia global del esc√°ner
scanner = MalwareScanner()

def scan_file_for_conversion(file_path: str) -> ScanResult:
    """
    Funci√≥n de conveniencia para escanear archivos antes de conversi√≥n.
    
    Args:
        file_path: Ruta al archivo a escanear
        
    Returns:
        ScanResult: Resultado del escaneo
    """
    return scanner.scan_file(file_path)

def is_file_safe_for_conversion(file_path: str) -> bool:
    """
    Verifica r√°pidamente si un archivo es seguro para conversi√≥n.
    
    Args:
        file_path: Ruta al archivo a verificar
        
    Returns:
        bool: True si el archivo es seguro, False en caso contrario
    """
    result = scanner.scan_file(file_path)
    return result.is_safe and result.threat_level == 'safe'
