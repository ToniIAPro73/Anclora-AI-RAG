"""
API REST para acceso de agentes IA al sistema Anclora RAG
"""

import json
import logging
import os
import secrets
from typing import List, Optional

from fastapi import Body, Depends, FastAPI, File, HTTPException, UploadFile
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field
from pydantic.config import ConfigDict
from common.langchain_module import response

# Configurar logging
logger = logging.getLogger(__name__)


class UTF8JSONResponse(JSONResponse):
    """JSONResponse que mantiene caracteres multilingües sin escapar."""

    def render(self, content) -> bytes:  # type: ignore[override]
        return json.dumps(
            content,
            ensure_ascii=False,
            allow_nan=False,
            indent=None,
            separators=(",", ":"),
        ).encode("utf-8")


# Configurar FastAPI
app = FastAPI(
    title="Anclora RAG API",
    description=(
        "API REST bilingüe para consultar y administrar el sistema Anclora RAG.\n\n"
        "This bilingual REST API allows you to query and manage the Anclora RAG system."
    ),
    version="1.0.0"
)

# Seguridad básica
security = HTTPBearer()

# Modelos Pydantic
class ChatRequest(BaseModel):
    message: str = Field(
        ...,
        description=(
            "Mensaje de la consulta o pregunta que se enviará al motor RAG.\n"
            "Query message or question that will be processed by the RAG engine."
        ),
        example="¿Cuál es la política de respaldo de datos?"
    )
    max_length: Optional[int] = Field(
        1000,
        description=(
            "Longitud máxima permitida para el mensaje. Ajusta el límite si necesitas respuestas extensas.\n"
            "Maximum number of characters allowed in the message. Increase the limit for longer prompts."
        ),
        example=800
    )
    language: Optional[str] = Field(
        'es',
        description=(
            "Idioma preferido para la respuesta (`es` o `en`).\n"
            "Preferred response language (`es` or `en`)."
        ),
        example="en"
    )

    model_config = ConfigDict(
        json_schema_extra={
            "example": {
                "message": "Provide a summary of the onboarding process.",
                "max_length": 600,
                "language": "en"
            }
        }
    )


    class Config:
        schema_extra = {
            "examples": [
                {
                    "message": "¿Cuál es el estado del informe trimestral?",
                    "max_length": 800,
                    "language": "es",
                },
                {
                    "message": "What's the status of the quarterly report?",
                    "max_length": 800,
                    "language": "en",
                },
            ]
        }

class ChatResponse(BaseModel):
    response: str = Field(
        ...,
        description=(
            "Respuesta generada por el sistema RAG. Puede incluir texto enriquecido.\n"
            "Answer generated by the RAG system. The text may contain references or summaries."
        ),
        example="La política de respaldo realiza copias incrementales cada 24 horas..."
    )
    status: str = Field(
        ...,
        description=(
            "Estado de la operación (`success` o `error`).\n"
            "Operation status (`success` or `error`)."
        ),
        example="success"
    )
    timestamp: str = Field(
        ...,
        description=(
            "Marca temporal ISO 8601 de la respuesta.\n"
            "ISO 8601 timestamp of the response."
        ),
        example="2024-05-12T14:32:10.456789"
    )

    model_config = ConfigDict(
        json_schema_extra={
            "example": {
                "response": "Las copias de seguridad se ejecutan automáticamente cada noche...",
                "status": "success",
                "timestamp": "2024-05-12T14:32:10.456789"
            }
        }
    )

    class Config:
        schema_extra = {
            "examples": [
                {
                    "response": "La base de conocimiento contiene 12 documentos y todo funciona correctamente.",
                    "status": "success",
                    "timestamp": "2024-05-04T12:00:00",
                },
                {
                    "response": "The knowledge base contains 12 documents and everything is running smoothly.",
                    "status": "success",
                    "timestamp": "2024-05-04T12:00:00",
                },
            ]
        }

class FileInfo(BaseModel):
    filename: str = Field(
        ...,
        description=(
            "Nombre del archivo almacenado en la base de conocimiento.\n"
            "Filename stored in the knowledge base."
        ),
        example="politica_seguridad.pdf"
    )
    status: str = Field(
        ...,
        description=(
            "Estado del procesamiento del archivo.\n"
            "Processing status for the uploaded file."
        ),
        example="indexed"
    )

    model_config = ConfigDict(
        json_schema_extra={
            "example": {
                "filename": "manual_instalacion.docx",
                "status": "indexed"
            }
        }
    )

class HealthResponse(BaseModel):
    status: str = Field(
        ...,
        description=(
            "Estado global del sistema.\n"
            "Overall health status of the system."
        ),
        example="healthy"
    )
    version: str = Field(
        ...,
        description=(
            "Versión desplegada de la API.\n"
            "Deployed API version."
        ),
        example="1.0.0"
    )
    services: dict = Field(
        ...,
        description=(
            "Mapa de servicios críticos y su estado operativo.\n"
            "Mapping of critical services and their operational status."
        ),
        example={"chroma_db": "healthy", "ollama": "healthy"}
    )

    model_config = ConfigDict(
        json_schema_extra={
            "example": {
                "status": "healthy",
                "version": "1.0.0",
                "services": {
                    "chroma_db": "healthy",
                    "ollama": "healthy",
                    "rag_system": "healthy"
                }
            }
        }
    )

try:  # pragma: no cover - la dependencia es opcional
    import jwt
    from jwt import PyJWTError
except Exception:  # pragma: no cover - entorno sin PyJWT
    jwt = None
    PyJWTError = Exception


def _get_allowed_tokens() -> List[str]:
    """Obtener los tokens válidos definidos en variables de entorno."""

    tokens: List[str] = []
    raw_tokens = os.getenv("ANCLORA_API_TOKENS")
    if raw_tokens:
        tokens.extend(
            token.strip() for token in raw_tokens.split(",") if token.strip()
        )

    single_token = os.getenv("ANCLORA_API_TOKEN")
    if single_token and single_token.strip():
        tokens.append(single_token.strip())

    # Mantener el orden pero eliminar duplicados
    seen = set()
    ordered_tokens: List[str] = []
    for token in tokens:
        if token not in seen:
            seen.add(token)
            ordered_tokens.append(token)

    return ordered_tokens


def _verify_jwt_token(token: str, secret: str) -> None:
    """Validar un JWT empleando la configuración del entorno."""

    if jwt is None:
        logger.error(
            "ANCLORA_JWT_SECRET está configurado pero PyJWT no está instalado"
        )
        raise HTTPException(
            status_code=500,
            detail="Configuración de autenticación inválida",
        )

    algorithms_env = os.getenv("ANCLORA_JWT_ALGORITHMS", "HS256")
    algorithms = [alg.strip() for alg in algorithms_env.split(",") if alg.strip()]
    if not algorithms:
        algorithms = ["HS256"]

    audience = os.getenv("ANCLORA_JWT_AUDIENCE")
    issuer = os.getenv("ANCLORA_JWT_ISSUER")

    decode_kwargs = {
        "algorithms": algorithms,
        "audience": audience or None,
        "issuer": issuer or None,
        "options": {"verify_aud": bool(audience)},
    }

    try:
        jwt.decode(token, secret, **decode_kwargs)
    except PyJWTError as exc:  # pragma: no cover - depende del contenido del token
        logger.warning("JWT inválido: %s", exc)
        raise HTTPException(status_code=401, detail="Token inválido") from exc


# Función de autenticación basada en variables de entorno / JWT
def verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """Verificar que el token recibido coincide con la configuración del entorno."""

    provided_token = credentials.credentials
    allowed_tokens = _get_allowed_tokens()

    for allowed in allowed_tokens:
        if secrets.compare_digest(provided_token, allowed):
            return provided_token

    jwt_secret = os.getenv("ANCLORA_JWT_SECRET")
    if jwt_secret:
        _verify_jwt_token(provided_token, jwt_secret)
        return provided_token

    if allowed_tokens:
        logger.warning("Intento de acceso con token no autorizado")
        raise HTTPException(status_code=401, detail="Token inválido")

    logger.error("No se configuraron credenciales de acceso para la API")
    raise HTTPException(status_code=500, detail="Autenticación no configurada")

@app.get(
    "/health",
    response_model=HealthResponse,
    summary="Health check / Verificación de estado",
    description=(
        "Verifica el estado general de la API, reporta la versión y el estado de los servicios críticos.\n\n"
        "Checks the overall API health, the deployed version, and reports the status of critical services."
    )
)
async def health_check():
    """Verifica la disponibilidad del sistema / Check system availability."""
    try:
        # Verificar servicios
        services_status = {
            "chroma_db": "healthy",
            "ollama": "healthy",
            "rag_system": "healthy"
        }
        
        return HealthResponse(
            status="healthy",
            version="1.0.0",
            services=services_status
        )
    except Exception as e:
        logger.error(f"Error en health check: {str(e)}")
        raise HTTPException(status_code=503, detail="Servicio no disponible")

@app.post(
    "/chat",
    response_model=ChatResponse,
    summary="Conversación con el RAG / Chat with RAG",
    description=(
        "Envía una consulta en español o inglés al motor RAG y recibe una respuesta contextualizada.\n\n"
        "Send a Spanish or English query to the RAG engine and receive a contextualised answer."
    )
)
async def chat_with_rag(
    request: ChatRequest = Body(
        ...,
        examples={
            "consulta_es": {
                "summary": "Consulta en español",
                "description": "Solicitud con caracteres acentuados para validar soporte UTF-8.",
                "value": {
                    "message": "¿Cuál es el estado del informe trimestral?",
                    "language": "es",
                    "max_length": 600,
                },
            },
            "query_en": {
                "summary": "Request in English",
                "description": "English request that showcases ñ/accents in the payload.",
                "value": {
                    "message": "Please summarize the jalapeño market update.",
                    "language": "en",
                    "max_length": 600,
                },
            },
        },
    ),
    token: str = Depends(verify_token)
):
    """Realiza consultas conversacionales al sistema Anclora RAG."""
    try:
        # Validar entrada
        if not request.message or len(request.message.strip()) == 0:
            raise HTTPException(status_code=400, detail="Mensaje vacío")
        
        if len(request.message) > request.max_length:
            raise HTTPException(
                status_code=400, 
                detail=f"Mensaje demasiado largo (máximo {request.max_length} caracteres)"
            )
        
        # Procesar consulta
        logger.info(f"Procesando consulta API: {request.message[:50]}...")
        language = (request.language or "es").lower()
        if language not in {"es", "en"}:
            language = "es"

        try:
            rag_response = response(request.message, language)
        except TypeError:
            rag_response = response(request.message)
        
        from datetime import datetime
        return ChatResponse(
            response=rag_response,
            status="success",
            timestamp=datetime.now().isoformat()
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error en chat API: {str(e)}")
        raise HTTPException(status_code=500, detail="Error interno del servidor")

@app.post(
    "/upload",
    summary="Subir documento / Upload document",
    description=(
        "Permite cargar un documento válido para que se procese e indexe en la base de conocimiento del RAG.\n\n"
        "Upload a valid document so it can be processed and indexed into the RAG knowledge base."
    )
)
async def upload_document(
    file: UploadFile = File(...),
    token: str = Depends(verify_token)
):

    """Carga un documento y lo envía al pipeline de ingesta / Uploads a document to the ingestion pipeline."""
    try:
        from common.ingest_file import ingest_file, validate_uploaded_file

        # Validar archivo
        is_valid, message = validate_uploaded_file(file)
        if not is_valid:
            raise HTTPException(status_code=400, detail=message)
        
        # Procesar archivo
        logger.info(f"Procesando archivo API: {file.filename}")
        ingest_file(file, file.filename)
        
        return {
            "status": "success",
            "message": f"Archivo '{file.filename}' procesado exitosamente",
            "filename": file.filename
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error en upload API: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al procesar archivo")

@app.get(
    "/documents",
    summary="Listar documentos / List documents",
    description=(
        "Devuelve la lista de fuentes únicas presentes en la base vectorial del RAG.\n\n"
        "Returns the list of unique sources available in the RAG vector database."
    )
)
async def list_documents(token: str = Depends(verify_token)):
    """Obtiene el catálogo de documentos actualmente indexados."""
    try:
        from common.chroma_db_settings import get_unique_sources_df
        from common.constants import CHROMA_SETTINGS

        files_df = get_unique_sources_df(CHROMA_SETTINGS)
        documents = files_df['Archivo'].tolist() if not files_df.empty else []
        
        return {
            "status": "success",
            "documents": documents,
            "count": len(documents)
        }
        
    except Exception as e:
        logger.error(f"Error al listar documentos: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al obtener documentos")

@app.delete(
    "/documents/{filename}",
    summary="Eliminar documento / Delete document",
    description=(
        "Elimina la referencia del documento indicado de la base de conocimiento RAG.\n\n"
        "Deletes the specified document reference from the RAG knowledge base."
    )
)
async def delete_document(
    filename: str,
    token: str = Depends(verify_token)
):
    """Elimina un documento indexado / Delete an indexed document."""
    try:
        from common.ingest_file import delete_file_from_vectordb
        delete_file_from_vectordb(filename)
        
        return {
            "status": "success",
            "message": f"Documento '{filename}' eliminado exitosamente"
        }
        
    except Exception as e:
        logger.error(f"Error al eliminar documento: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al eliminar documento")

# Middleware para CORS (si es necesario)
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Configurar según necesidades
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8081)

